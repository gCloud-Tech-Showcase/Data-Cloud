config {
  type: "incremental",
  schema: "sentiment_analysis",
  description: "SILVER: Gemini-enriched review sentiment analysis with cleansing and validation",
  tags: ["sentiment_analysis", "silver", "staging"],
  uniqueKey: ["review_id"],
  columns: {
    uri: "GCS URI of the source JSON file",
    platform: "Source platform (e.g., play_store)",
    review_id: "Unique identifier for the review",
    user_pseudo_id: "Anonymous user identifier if available",
    user_name: "Display name of the reviewer",
    review_date: "Date the review was posted",
    rating: "Star rating given by the user (1-5)",
    app_version: "Version of the app being reviewed",
    thumbs_up_count: "Number of helpful votes the review received",
    review_text: "Full text content of the review",
    developer_reply: "Developer's response to the review if any",
    sentiment: "Gemini-detected sentiment: positive, neutral, or negative",
    category: "Gemini-detected complaint category: performance, ads, difficulty, bugs, praise, or other",
    sentiment_score: "Gemini-assigned sentiment score from -1 (very negative) to 1 (very positive)"
  }
}

SELECT
  uri,

  -- Extract original review fields from JSON (data_string already converted from BYTES in subquery)
  JSON_EXTRACT_SCALAR(data_string, '$.platform') AS platform,
  JSON_EXTRACT_SCALAR(data_string, '$.review_id') AS review_id,
  JSON_EXTRACT_SCALAR(data_string, '$.user_pseudo_id') AS user_pseudo_id,
  JSON_EXTRACT_SCALAR(data_string, '$.user_name') AS user_name,
  PARSE_DATE('%Y-%m-%d', JSON_EXTRACT_SCALAR(data_string, '$.review_date')) AS review_date,
  CAST(JSON_EXTRACT_SCALAR(data_string, '$.rating') AS INT64) AS rating,
  JSON_EXTRACT_SCALAR(data_string, '$.app_version') AS app_version,
  CAST(JSON_EXTRACT_SCALAR(data_string, '$.thumbs_up_count') AS INT64) AS thumbs_up_count,
  JSON_EXTRACT_SCALAR(data_string, '$.review_text') AS review_text,
  JSON_EXTRACT_SCALAR(data_string, '$.developer_reply') AS developer_reply,

  -- Gemini-extracted sentiment fields (flatten_json_output=TRUE returns raw JSON)
  JSON_EXTRACT_SCALAR(ml_generate_text_llm_result, '$.sentiment') AS sentiment,
  JSON_EXTRACT_SCALAR(ml_generate_text_llm_result, '$.category') AS category,
  SAFE_CAST(JSON_EXTRACT_SCALAR(ml_generate_text_llm_result, '$.score') AS FLOAT64) AS sentiment_score

FROM
  ML.GENERATE_TEXT(
    MODEL ${ref("gemini_sentiment_model")},
    (
      SELECT
        uri,
        SAFE_CONVERT_BYTES_TO_STRING(data) AS data_string,
        CONCAT(
          'Analyze this app review and return ONLY a raw JSON object with no markdown formatting, no code fences, no explanation.\n',
          'Return exactly this structure: {"sentiment": "positive|neutral|negative", ',
          '"category": "performance|ads|difficulty|bugs|praise|other", ',
          '"score": <number from -1 to 1>}\n\n',
          'Review text: ',
          JSON_EXTRACT_SCALAR(SAFE_CONVERT_BYTES_TO_STRING(data), '$.review_text')
        ) AS prompt
      FROM ${ref("bronze_user_reviews")}
      ${when(incremental(), `WHERE JSON_EXTRACT_SCALAR(SAFE_CONVERT_BYTES_TO_STRING(data), '$.review_id') NOT IN (SELECT review_id FROM ${self()})`)}
    ),
    STRUCT(
      0.2 AS temperature,
      1024 AS max_output_tokens,
      TRUE AS flatten_json_output
    )
  )